{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "logger",
  "type": "registry:block",
  "title": "Logger",
  "author": "Jona630 https://github.com/Jona630",
  "description": "Logger",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "planetary/template/vite/src/common/utils/logger.ts",
      "content": "// import { PostHog } from \"posthog-node\";\nimport { envVars } from \"./environment\";\n\nexport enum LogLevel {\n  DEBUG = \"debug\",\n  INFO = \"info\",\n  WARN = \"warn\",\n  ERROR = \"error\",\n}\n\n// ANSI color codes for terminal output\nconst colors = {\n  reset: \"\\x1b[0m\",\n  bright: \"\\x1b[1m\",\n  dim: \"\\x1b[2m\",\n  red: \"\\x1b[31m\",\n  green: \"\\x1b[32m\",\n  yellow: \"\\x1b[33m\",\n  blue: \"\\x1b[34m\",\n  magenta: \"\\x1b[35m\",\n  cyan: \"\\x1b[36m\",\n  white: \"\\x1b[37m\",\n  gray: \"\\x1b[90m\",\n};\n\n// Color mapping for log levels\nconst levelColors = {\n  [LogLevel.DEBUG]: colors.gray,\n  [LogLevel.INFO]: colors.blue,\n  [LogLevel.WARN]: colors.yellow,\n  [LogLevel.ERROR]: colors.red,\n};\n\ntype LogData = Record<string, any>;\n\n// Initialize PostHog client\n// let posthogClient: PostHog | null = null;\n\n// if (env.POSTHOG_API_KEY) {\n//   posthogClient = new PostHog(env.POSTHOG_API_KEY, {\n//     host: env.POSTHOG_HOST,\n//     flushAt: 1, // Send events immediately in development\n//     flushInterval: 1000, // Flush every second\n//   });\n\n//   // Graceful shutdown\n//   process.on(\"SIGINT\", async () => {\n//     if (posthogClient) {\n//       await posthogClient.shutdown();\n//     }\n//   });\n\n//   process.on(\"SIGTERM\", async () => {\n//     if (posthogClient) {\n//       await posthogClient.shutdown();\n//     }\n//   });\n// }\n\nclass Logger {\n  private formatForConsole(\n    level: LogLevel,\n    message: string,\n    data?: LogData\n  ): string {\n    const timestamp = new Date().toISOString();\n    const color = levelColors[level];\n    const levelText = level.toUpperCase().padEnd(5);\n\n    // Only add colors if we're in a TTY (terminal) environment\n    const isColorSupported =\n      process.stdout.isTTY && envVars.NODE_ENV !== \"production\";\n\n    if (isColorSupported) {\n      const coloredLevel = `${color}${colors.bright}${levelText}${colors.reset}`;\n      const coloredTimestamp = `${colors.gray}${timestamp}${colors.reset}`;\n      let formattedMessage = `${coloredTimestamp} ${coloredLevel} ${message}`;\n\n      if (data && Object.keys(data).length > 0) {\n        const dataString = JSON.stringify(data, null, 2);\n        formattedMessage += `\\n${colors.dim}${dataString}${colors.reset}`;\n      }\n\n      return formattedMessage;\n    } else {\n      // Fallback to plain text for production or non-TTY environments\n      let formattedMessage = `${timestamp} ${levelText} ${message}`;\n      if (data && Object.keys(data).length > 0) {\n        formattedMessage += `\\n${JSON.stringify(data, null, 2)}`;\n      }\n      return formattedMessage;\n    }\n  }\n\n  private log(level: LogLevel, message: string, data?: LogData) {\n    const timestamp = new Date().toISOString();\n    const logObject = {\n      level,\n      timestamp,\n      message,\n      ...data,\n    };\n\n    // Output colored logs to the console for development\n    if (envVars.NODE_ENV === \"development\") {\n      console.log(this.formatForConsole(level, message, data));\n    }\n\n    // Send logs to PostHog for analytics and monitoring\n    // if (posthogClient) {\n    //   try {\n    //     // Determine distinct ID from context\n    //     const distinctId =\n    //       data?.userId?.toString() ||\n    //       data?.telegramChatId?.toString() ||\n    //       data?.alertId?.toString() ||\n    //       \"my-app\";\n\n    //     // Create event name based on log level and context\n    //     const eventName = this.createEventName(level, message, data);\n\n    //     posthogClient.capture({\n    //       distinctId,\n    //       event: eventName,\n    //       properties: {\n    //         ...logObject,\n    //         // Add system context\n    //         environment: env.NODE_ENV || \"development\",\n    //         service: \"my-app\",\n    //         hostname: env.HOSTNAME || \"unknown\",\n    //         version: env.npm_package_version || \"1.0.0\",\n    //       },\n    //     });\n    //   } catch (error) {\n    //     // Don't let PostHog errors break the application\n    //     console.error(\"Failed to send log to PostHog:\", error);\n    //   }\n    // }\n  }\n\n  private createEventName(\n    level: LogLevel,\n    message: string,\n    data?: LogData\n  ): string {\n    // Create meaningful event names for different log types\n    if (data?.alertId) return `Alert ${level}: ${message}`;\n    if (data?.userId) return `User ${level}: ${message}`;\n    // and so on\n\n    // Fallback to generic system event\n    return `System ${level}: ${message}`;\n  }\n\n  public debug(message: string, data?: LogData) {\n    // You might want to log debug messages only in development\n    if (envVars.NODE_ENV !== \"production\") {\n      this.log(LogLevel.DEBUG, message, data);\n    }\n  }\n\n  public info(message: string, data?: LogData) {\n    this.log(LogLevel.INFO, message, data);\n  }\n\n  public warn(message: string, data?: LogData) {\n    this.log(LogLevel.WARN, message, data);\n  }\n\n  public error(message: string, error: Error, data?: LogData) {\n    this.log(LogLevel.ERROR, message, {\n      ...data,\n      error: {\n        message: error.message,\n        stack: error.stack,\n      },\n    });\n  }\n}\n\nexport const logger = new Logger();\n",
      "type": "registry:file",
      "target": "src/common/utils/logger.ts"
    }
  ]
}